import { createHash, randomUUID } from "node:crypto";
import { execFile } from "node:child_process";
import fs from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { promisify } from "node:util";

import puppeteer from "puppeteer-core";

import { sendEmail, type SmtpConfig } from "@virtuasoc/integration-email";
import { postWebhook } from "@virtuasoc/integration-webhook";
import { sendTeamsWebhook } from "@virtuasoc/integration-teams";

import type { Db } from "../db.js";

export type DistributeProductJobPayload = {
  tenantId: string;
  productId: string;
  distributionTargetIds?: string[];
  actorUserId?: string | null;
  renderOnly?: boolean;
  exportFormats?: ("pdf" | "docx")[]; // when renderOnly=true, controls which exports to produce
};

type ProductRow = {
  id: string;
  product_type: string;
  title: string;
  status: string;
  content_markdown: string | null;
  content_json: any;
};

type DistributionTargetRow = {
  id: string;
  kind: string;
  label: string | null;
  value: string;
  enabled: boolean;
};

function getSmtpConfig(): SmtpConfig | null {
  const host = (process.env.SMTP_HOST ?? "").trim();
  if (!host) return null;
  const port = Number(process.env.SMTP_PORT ?? "587");
  const user = (process.env.SMTP_USER ?? "").trim();
  const pass = (process.env.SMTP_PASS ?? "").trim();
  const from = (process.env.SMTP_FROM ?? "").trim();
  if (!user || !pass || !from) return null;
  return { host, port: Number.isFinite(port) ? port : 587, user, pass, from };
}

function redactPii(text: string): string {
  if ((process.env.REDACT_PII_ON_DISTRIBUTION ?? "true") === "false") return text;
  return (
    text
      // emails
      .replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi, "[REDACTED_EMAIL]")
      // SSN
      .replace(/\b\d{3}-\d{2}-\d{4}\b/g, "[REDACTED_SSN]")
      // loose-ish phone patterns
      .replace(/\b(\+?\d{1,2}\s*)?(\(?\d{3}\)?[\s.-]?)\d{3}[\s.-]?\d{4}\b/g, "[REDACTED_PHONE]")
  );
}

function escapeHtml(text: string): string {
  return text
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function safeFilename(raw: string): string {
  const s = String(raw ?? "").trim().slice(0, 80) || "product";
  return s.replace(/[^\w\-(). ]+/g, "_");
}

function chromiumExecutablePath(): string {
  const envPath = (process.env.CHROMIUM_PATH ?? "").trim();
  if (envPath) {
    if (!fs.existsSync(envPath)) throw new Error(`CHROMIUM_PATH does not exist: ${envPath}`);
    return envPath;
  }
  // Common Alpine paths
  const candidates = ["/usr/bin/chromium-browser", "/usr/bin/chromium"];
  for (const c of candidates) {
    try {
      if (fs.existsSync(c)) return c;
    } catch {
      // ignore
    }
  }
  throw new Error("Chromium executable not found. Set CHROMIUM_PATH (or install chromium in the worker image).");
}

const execFileAsync = promisify(execFile);

async function renderMarkdownToPdf(markdown: string): Promise<{ bytes: Buffer; sha256: string }> {
  const text = redactPii(markdown);
  const html = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>IPF Product</title>
    <style>
      html, body { margin: 0; padding: 0; }
      body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      .page { padding: 28px; }
      pre { white-space: pre-wrap; word-wrap: break-word; font-size: 11px; line-height: 1.35; }
      .footer { margin-top: 18px; font-size: 10px; color: #666; }
    </style>
  </head>
  <body>
    <div class="page">
      <pre>${escapeHtml(text)}</pre>
      <div class="footer">Generated by VirtuaSOC IPF</div>
    </div>
  </body>
</html>`;

  const browser = await puppeteer.launch({
    executablePath: chromiumExecutablePath(),
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  try {
    const page = await browser.newPage();
    await page.setJavaScriptEnabled(false);
    await page.setContent(html, { waitUntil: "load" });
    const bytes = await page.pdf({
      format: "A4",
      printBackground: true,
      margin: { top: "20mm", bottom: "20mm", left: "16mm", right: "16mm" },
    });
    const sha256 = createHash("sha256").update(bytes).digest("hex");
    return { bytes, sha256 };
  } finally {
    await browser.close();
  }
}

async function renderMarkdownToDocx(markdown: string, referenceDocxBytes?: Buffer): Promise<{ bytes: Buffer; sha256: string }> {
  const text = redactPii(markdown);
  const dir = await fs.promises.mkdtemp(join(tmpdir(), "ipf-docx-"));
  const mdPath = join(dir, "input.md");
  const outPath = join(dir, "output.docx");
  const refPath = join(dir, "reference.docx");

  try {
    await fs.promises.writeFile(mdPath, text, "utf8");
    if (referenceDocxBytes?.length) {
      await fs.promises.writeFile(refPath, referenceDocxBytes);
    }

    const args = ["--from", "gfm", "--to", "docx", "--output", outPath, mdPath];
    if (referenceDocxBytes?.length) {
      args.splice(0, 0, "--reference-doc", refPath);
    }

    try {
      await execFileAsync("pandoc", args, { timeout: 30_000, windowsHide: true } as any);
    } catch (err) {
      const msg = String((err as any)?.message ?? err);
      throw new Error(`DOCX export failed (pandoc): ${msg}`);
    }

    const bytes = await fs.promises.readFile(outPath);
    const sha256 = createHash("sha256").update(bytes).digest("hex");
    return { bytes, sha256 };
  } finally {
    await fs.promises.rm(dir, { recursive: true, force: true }).catch(() => undefined);
  }
}

async function loadTenantDocxTemplate(db: Db, tenantId: string): Promise<{ bytes: Buffer; contentType: string } | null> {
  try {
    const rows = await db<{ docx_bytes: Buffer; content_type: string }[]>`
      SELECT docx_bytes, content_type
      FROM tenant_docx_templates
      WHERE tenant_id = ${tenantId}
      LIMIT 1
    `;
    const r = rows[0];
    if (!r?.docx_bytes) return null;
    const ct =
      typeof r.content_type === "string" && r.content_type.trim()
        ? r.content_type.trim()
        : "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    return { bytes: r.docx_bytes, contentType: ct };
  } catch (err) {
    const msg = String((err as any)?.message ?? err);
    if (msg.includes("relation") && msg.includes("tenant_docx_templates")) return null;
    throw err;
  }
}

async function loadProductDistributionRules(db: Db, tenantId: string, productType: string): Promise<any> {
  try {
    const rows = await db<{ distribution_rules: any }[]>`
      SELECT distribution_rules
      FROM product_configs
      WHERE tenant_id = ${tenantId} AND product_type = ${productType}
      LIMIT 1
    `;
    return rows[0]?.distribution_rules ?? {};
  } catch {
    return {};
  }
}

async function upsertProductExport(
  db: Db,
  tenantId: string,
  productId: string,
  exports: {
    pdf?: { bytes: Buffer; sha256: string };
    docx?: { bytes: Buffer; sha256: string };
    docxContentType?: string;
  },
) {
  await db`
    INSERT INTO product_exports (
      product_id, tenant_id,
      pdf_bytes, pdf_sha256, content_type,
      docx_bytes, docx_sha256, docx_content_type,
      created_at, updated_at
    )
    VALUES (
      ${productId},
      ${tenantId},
      ${exports.pdf?.bytes ?? null},
      ${exports.pdf?.sha256 ?? null},
      ${"application/pdf"},
      ${exports.docx?.bytes ?? null},
      ${exports.docx?.sha256 ?? null},
      ${exports.docx ? (exports.docxContentType ?? "application/vnd.openxmlformats-officedocument.wordprocessingml.document") : null},
      NOW(),
      NOW()
    )
    ON CONFLICT (product_id) DO UPDATE SET
      pdf_bytes = COALESCE(EXCLUDED.pdf_bytes, product_exports.pdf_bytes),
      pdf_sha256 = COALESCE(EXCLUDED.pdf_sha256, product_exports.pdf_sha256),
      content_type = COALESCE(EXCLUDED.content_type, product_exports.content_type),
      docx_bytes = COALESCE(EXCLUDED.docx_bytes, product_exports.docx_bytes),
      docx_sha256 = COALESCE(EXCLUDED.docx_sha256, product_exports.docx_sha256),
      docx_content_type = COALESCE(EXCLUDED.docx_content_type, product_exports.docx_content_type),
      updated_at = NOW()
  `;
}

async function listTargets(db: Db, tenantId: string, ids?: string[]): Promise<DistributionTargetRow[]> {
  if (ids?.length) {
    return await db<DistributionTargetRow[]>`
      SELECT id, kind, label, value, enabled
      FROM distribution_targets
      WHERE tenant_id = ${tenantId} AND enabled = true AND id = ANY(${db.array(ids, 2950)})
      ORDER BY created_at DESC
    `;
  }
  return await db<DistributionTargetRow[]>`
    SELECT id, kind, label, value, enabled
    FROM distribution_targets
    WHERE tenant_id = ${tenantId} AND enabled = true
    ORDER BY created_at DESC
  `;
}

async function createDistributionRecord(db: Db, tenantId: string, productId: string, t: DistributionTargetRow) {
  const id = randomUUID();
  await db`
    INSERT INTO product_distribution_records (id, tenant_id, product_id, kind, target, status, metadata)
    VALUES (
      ${id},
      ${tenantId},
      ${productId},
      ${t.kind},
      ${t.value},
      ${"pending"},
      ${db.json({ targetId: t.id, label: t.label })}
    )
  `;
  return id;
}

async function updateDistributionRecord(db: Db, tenantId: string, id: string, status: string, error?: string | null) {
  await db`
    UPDATE product_distribution_records
    SET status = ${status},
        sent_at = CASE WHEN ${status} = 'sent' THEN NOW() ELSE sent_at END,
        error = ${error ?? null}
    WHERE tenant_id = ${tenantId} AND id = ${id}
  `;
}

export async function distributeProduct(db: Db, payload: DistributeProductJobPayload) {
  const enabled = (process.env.FEATURE_REVIEW_DISTRIBUTION ?? "false").trim().toLowerCase() === "true";
  if (!enabled) throw new Error("FEATURE_REVIEW_DISTRIBUTION is not enabled");

  const tenantId = payload.tenantId;
  const productId = payload.productId;
  const actor = payload.actorUserId ?? null;

  const runId = randomUUID();
  await db`
    INSERT INTO run_logs (id, tenant_id, kind, status, model, input)
    VALUES (
      ${runId},
      ${tenantId},
      ${payload.renderOnly ? "products.export_pdf" : "products.distribute"},
      ${"started"},
      ${null},
      ${db.json({ productId, distributionTargetIds: payload.distributionTargetIds ?? null, renderOnly: !!payload.renderOnly })}
    )
  `;

  try {
    const products = await db<ProductRow[]>`
      SELECT id, product_type, title, status, content_markdown, content_json
      FROM products
      WHERE tenant_id = ${tenantId} AND id = ${productId}
      LIMIT 1
    `;
    if (!products.length) throw new Error("Product not found");
    const product = products[0]!;
    if (!payload.renderOnly && product.status !== "approved") {
      throw new Error("Product must be approved before distribution");
    }
    const markdown = product.content_markdown?.trim() || "";
    if (!markdown) throw new Error("Product has no rendered markdown");

    // Determine targets + distribution rules before deciding exports.
    // - renderOnly: honor payload.exportFormats (default pdf if none provided)
    // - distribute: always export PDF; export DOCX only if enabled by rules AND there's an email target selected
    const targets = payload.renderOnly ? [] : await listTargets(db, tenantId, payload.distributionTargetIds);
    if (!payload.renderOnly && !targets.length) throw new Error("No enabled distribution targets selected");

    const rules = await loadProductDistributionRules(db, tenantId, product.product_type);
    const includeDocxEmailAttachment = Boolean(rules?.includeDocxEmailAttachment);
    const hasEmailTarget = targets.some((t) => t.kind === "email");

    const requested = Array.isArray(payload.exportFormats) ? payload.exportFormats.map(String) : [];
    const exportFormats = Array.from(new Set(requested)).filter((x) => x === "pdf" || x === "docx");

    const shouldExportPdf = payload.renderOnly ? (exportFormats.length === 0 || exportFormats.includes("pdf")) : true;
    const shouldExportDocx = payload.renderOnly ? exportFormats.includes("docx") : includeDocxEmailAttachment && hasEmailTarget;

    const tenantTemplate = shouldExportDocx ? await loadTenantDocxTemplate(db, tenantId) : null;

    const pdf = shouldExportPdf ? await renderMarkdownToPdf(markdown) : null;
    const docx = shouldExportDocx ? await renderMarkdownToDocx(markdown, tenantTemplate?.bytes) : null;

    await upsertProductExport(db, tenantId, productId, {
      ...(pdf ? { pdf } : {}),
      ...(docx ? { docx } : {}),
      docxContentType: tenantTemplate?.contentType ?? "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    });

    if (payload.renderOnly) {
      await db`
        INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
        VALUES (
          ${randomUUID()},
          ${tenantId},
          ${docx ? "product.exported_docx" : "product.exported_pdf"},
          ${actor},
          ${"product"},
          ${productId},
          ${db.json({ pdfSha256: pdf?.sha256 ?? null, docxSha256: docx?.sha256 ?? null, formats: exportFormats.length ? exportFormats : ["pdf"] })}
        )
      `;

      await db`
        UPDATE run_logs
        SET status = ${"succeeded"},
            output = ${db.json({ productId, pdfSha256: pdf?.sha256 ?? null, docxSha256: docx?.sha256 ?? null, formats: exportFormats.length ? exportFormats : ["pdf"] })}
        WHERE id = ${runId}
      `;
      return;
    }

    const smtp = getSmtpConfig();

    let anyFailed = false;
    for (const t of targets) {
      const distributionId = await createDistributionRecord(db, tenantId, productId, t);
      await updateDistributionRecord(db, tenantId, distributionId, "sending", null);
      try {
        if (t.kind === "email") {
          if (!smtp) throw new Error("SMTP not configured (SMTP_HOST/PORT/USER/PASS/FROM)");
          const to = (t.value ?? "").trim();
          if (!to) throw new Error("Missing email target");
          if (!pdf) throw new Error("PDF export missing (cannot email without PDF)");
          await sendEmail(smtp, to, product.title, redactPii(markdown), {
            attachments: [
              { filename: `${safeFilename(product.title)}.pdf`, content: pdf.bytes, contentType: "application/pdf" },
              ...(includeDocxEmailAttachment && docx
                ? [
                    {
                      filename: `${safeFilename(product.title)}.docx`,
                      content: docx.bytes,
                      contentType: tenantTemplate?.contentType ?? "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    },
                  ]
                : []),
            ],
          });
        } else if (t.kind === "webhook") {
          const url = (t.value ?? "").trim();
          if (!url) throw new Error("Missing webhook URL");
          await postWebhook(url, {
            kind: "ipf_product",
            productId,
            title: product.title,
            status: product.status,
            pdfSha256: pdf?.sha256 ?? null,
            docxSha256: docx?.sha256 ?? null,
            // Include PDF inline only if explicitly enabled (size/cost control).
            pdfBase64:
              (process.env.WEBHOOK_INCLUDE_PDF_BASE64 ?? "false") === "true" && pdf ? pdf.bytes.toString("base64") : undefined,
            contentMarkdown: redactPii(markdown),
            contentJson: product.content_json ?? {},
          });
        } else if (t.kind === "teams_webhook") {
          const url = (t.value ?? "").trim();
          if (!url) throw new Error("Missing Teams webhook URL");
          await sendTeamsWebhook(url, { title: product.title, text: redactPii(markdown).slice(0, 3500) });
        } else {
          throw new Error(`Unsupported distribution target kind: ${t.kind}`);
        }

        await updateDistributionRecord(db, tenantId, distributionId, "sent", null);
        await db`
          INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
          VALUES (
            ${randomUUID()},
            ${tenantId},
            ${"product.distribution.sent"},
            ${actor},
            ${"product"},
            ${productId},
            ${db.json({ distributionId, kind: t.kind, target: t.value, pdfSha256: pdf?.sha256 ?? null, docxSha256: docx?.sha256 ?? null })}
          )
        `;
      } catch (err) {
        anyFailed = true;
        const message = String((err as any)?.message ?? err);
        await updateDistributionRecord(db, tenantId, distributionId, "failed", message);
        await db`
          INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
          VALUES (
            ${randomUUID()},
            ${tenantId},
            ${"product.distribution.failed"},
            ${actor},
            ${"product"},
            ${productId},
            ${db.json({ distributionId, kind: t.kind, target: t.value, error: message })}
          )
        `;
      }
    }

    if (!anyFailed) {
      await db`
        UPDATE products
        SET status = ${"distributed"}, distributed_at = NOW(), updated_at = NOW()
        WHERE tenant_id = ${tenantId} AND id = ${productId} AND status = ${"approved"}
      `;
    }

    await db`
      UPDATE run_logs
      SET status = ${anyFailed ? "partial_failed" : "succeeded"},
          output = ${db.json({ productId, pdfSha256: pdf?.sha256 ?? null, docxSha256: docx?.sha256 ?? null, targets: targets.map((t) => ({ kind: t.kind, value: t.value })) })}
      WHERE id = ${runId}
    `;
  } catch (err) {
    const message = String((err as any)?.message ?? err);
    await db`
      UPDATE run_logs
      SET status = ${"failed"},
          error = ${message}
      WHERE id = ${runId}
    `;
    throw err;
  }
}


