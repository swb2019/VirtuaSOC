import { createHash, randomUUID } from "node:crypto";
import fs from "node:fs";

import puppeteer from "puppeteer-core";

import { sendEmail, type SmtpConfig } from "@virtuasoc/integration-email";
import { postWebhook } from "@virtuasoc/integration-webhook";
import { sendTeamsWebhook } from "@virtuasoc/integration-teams";

import type { Db } from "../db.js";

export type DistributeProductJobPayload = {
  tenantId: string;
  productId: string;
  distributionTargetIds?: string[];
  actorUserId?: string | null;
  renderOnly?: boolean;
};

type ProductRow = {
  id: string;
  title: string;
  status: string;
  content_markdown: string | null;
  content_json: any;
};

type DistributionTargetRow = {
  id: string;
  kind: string;
  label: string | null;
  value: string;
  enabled: boolean;
};

function getSmtpConfig(): SmtpConfig | null {
  const host = (process.env.SMTP_HOST ?? "").trim();
  if (!host) return null;
  const port = Number(process.env.SMTP_PORT ?? "587");
  const user = (process.env.SMTP_USER ?? "").trim();
  const pass = (process.env.SMTP_PASS ?? "").trim();
  const from = (process.env.SMTP_FROM ?? "").trim();
  if (!user || !pass || !from) return null;
  return { host, port: Number.isFinite(port) ? port : 587, user, pass, from };
}

function redactPii(text: string): string {
  if ((process.env.REDACT_PII_ON_DISTRIBUTION ?? "true") === "false") return text;
  return (
    text
      // emails
      .replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi, "[REDACTED_EMAIL]")
      // SSN
      .replace(/\b\d{3}-\d{2}-\d{4}\b/g, "[REDACTED_SSN]")
      // loose-ish phone patterns
      .replace(/\b(\+?\d{1,2}\s*)?(\(?\d{3}\)?[\s.-]?)\d{3}[\s.-]?\d{4}\b/g, "[REDACTED_PHONE]")
  );
}

function escapeHtml(text: string): string {
  return text
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function safeFilename(raw: string): string {
  const s = String(raw ?? "").trim().slice(0, 80) || "product";
  return s.replace(/[^\w\-(). ]+/g, "_");
}

function chromiumExecutablePath(): string {
  const envPath = (process.env.CHROMIUM_PATH ?? "").trim();
  if (envPath) {
    if (!fs.existsSync(envPath)) throw new Error(`CHROMIUM_PATH does not exist: ${envPath}`);
    return envPath;
  }
  // Common Alpine paths
  const candidates = ["/usr/bin/chromium-browser", "/usr/bin/chromium"];
  for (const c of candidates) {
    try {
      if (fs.existsSync(c)) return c;
    } catch {
      // ignore
    }
  }
  throw new Error("Chromium executable not found. Set CHROMIUM_PATH (or install chromium in the worker image).");
}

async function renderMarkdownToPdf(markdown: string): Promise<{ bytes: Buffer; sha256: string }> {
  const text = redactPii(markdown);
  const html = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>IPF Product</title>
    <style>
      html, body { margin: 0; padding: 0; }
      body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      .page { padding: 28px; }
      pre { white-space: pre-wrap; word-wrap: break-word; font-size: 11px; line-height: 1.35; }
      .footer { margin-top: 18px; font-size: 10px; color: #666; }
    </style>
  </head>
  <body>
    <div class="page">
      <pre>${escapeHtml(text)}</pre>
      <div class="footer">Generated by VirtuaSOC IPF</div>
    </div>
  </body>
</html>`;

  const browser = await puppeteer.launch({
    executablePath: chromiumExecutablePath(),
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  try {
    const page = await browser.newPage();
    await page.setJavaScriptEnabled(false);
    await page.setContent(html, { waitUntil: "load" });
    const bytes = await page.pdf({
      format: "A4",
      printBackground: true,
      margin: { top: "20mm", bottom: "20mm", left: "16mm", right: "16mm" },
    });
    const sha256 = createHash("sha256").update(bytes).digest("hex");
    return { bytes, sha256 };
  } finally {
    await browser.close();
  }
}

async function upsertProductExport(db: Db, tenantId: string, productId: string, pdf: { bytes: Buffer; sha256: string }) {
  await db`
    INSERT INTO product_exports (product_id, tenant_id, pdf_bytes, pdf_sha256, content_type, created_at, updated_at)
    VALUES (${productId}, ${tenantId}, ${pdf.bytes}, ${pdf.sha256}, ${"application/pdf"}, NOW(), NOW())
    ON CONFLICT (product_id) DO UPDATE SET
      pdf_bytes = EXCLUDED.pdf_bytes,
      pdf_sha256 = EXCLUDED.pdf_sha256,
      content_type = EXCLUDED.content_type,
      updated_at = NOW()
  `;
}

async function listTargets(db: Db, tenantId: string, ids?: string[]): Promise<DistributionTargetRow[]> {
  if (ids?.length) {
    return await db<DistributionTargetRow[]>`
      SELECT id, kind, label, value, enabled
      FROM distribution_targets
      WHERE tenant_id = ${tenantId} AND enabled = true AND id = ANY(${db.array(ids, 2950)})
      ORDER BY created_at DESC
    `;
  }
  return await db<DistributionTargetRow[]>`
    SELECT id, kind, label, value, enabled
    FROM distribution_targets
    WHERE tenant_id = ${tenantId} AND enabled = true
    ORDER BY created_at DESC
  `;
}

async function createDistributionRecord(db: Db, tenantId: string, productId: string, t: DistributionTargetRow) {
  const id = randomUUID();
  await db`
    INSERT INTO product_distribution_records (id, tenant_id, product_id, kind, target, status, metadata)
    VALUES (
      ${id},
      ${tenantId},
      ${productId},
      ${t.kind},
      ${t.value},
      ${"pending"},
      ${db.json({ targetId: t.id, label: t.label })}
    )
  `;
  return id;
}

async function updateDistributionRecord(db: Db, tenantId: string, id: string, status: string, error?: string | null) {
  await db`
    UPDATE product_distribution_records
    SET status = ${status},
        sent_at = CASE WHEN ${status} = 'sent' THEN NOW() ELSE sent_at END,
        error = ${error ?? null}
    WHERE tenant_id = ${tenantId} AND id = ${id}
  `;
}

export async function distributeProduct(db: Db, payload: DistributeProductJobPayload) {
  const enabled = (process.env.FEATURE_REVIEW_DISTRIBUTION ?? "false").trim().toLowerCase() === "true";
  if (!enabled) throw new Error("FEATURE_REVIEW_DISTRIBUTION is not enabled");

  const tenantId = payload.tenantId;
  const productId = payload.productId;
  const actor = payload.actorUserId ?? null;

  const runId = randomUUID();
  await db`
    INSERT INTO run_logs (id, tenant_id, kind, status, model, input)
    VALUES (
      ${runId},
      ${tenantId},
      ${payload.renderOnly ? "products.export_pdf" : "products.distribute"},
      ${"started"},
      ${null},
      ${db.json({ productId, distributionTargetIds: payload.distributionTargetIds ?? null, renderOnly: !!payload.renderOnly })}
    )
  `;

  try {
    const products = await db<ProductRow[]>`
      SELECT id, title, status, content_markdown, content_json
      FROM products
      WHERE tenant_id = ${tenantId} AND id = ${productId}
      LIMIT 1
    `;
    if (!products.length) throw new Error("Product not found");
    const product = products[0]!;
    if (!payload.renderOnly && product.status !== "approved") {
      throw new Error("Product must be approved before distribution");
    }
    const markdown = product.content_markdown?.trim() || "";
    if (!markdown) throw new Error("Product has no rendered markdown");

    const pdf = await renderMarkdownToPdf(markdown);
    await upsertProductExport(db, tenantId, productId, pdf);

    if (payload.renderOnly) {
      await db`
        INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
        VALUES (
          ${randomUUID()},
          ${tenantId},
          ${"product.exported_pdf"},
          ${actor},
          ${"product"},
          ${productId},
          ${db.json({ pdfSha256: pdf.sha256 })}
        )
      `;

      await db`
        UPDATE run_logs
        SET status = ${"succeeded"},
            output = ${db.json({ productId, pdfSha256: pdf.sha256 })}
        WHERE id = ${runId}
      `;
      return;
    }

    const targets = await listTargets(db, tenantId, payload.distributionTargetIds);
    if (!targets.length) throw new Error("No enabled distribution targets selected");

    const smtp = getSmtpConfig();

    let anyFailed = false;
    for (const t of targets) {
      const distributionId = await createDistributionRecord(db, tenantId, productId, t);
      await updateDistributionRecord(db, tenantId, distributionId, "sending", null);
      try {
        if (t.kind === "email") {
          if (!smtp) throw new Error("SMTP not configured (SMTP_HOST/PORT/USER/PASS/FROM)");
          const to = (t.value ?? "").trim();
          if (!to) throw new Error("Missing email target");
          await sendEmail(smtp, to, product.title, redactPii(markdown), {
            attachments: [{ filename: `${safeFilename(product.title)}.pdf`, content: pdf.bytes, contentType: "application/pdf" }],
          });
        } else if (t.kind === "webhook") {
          const url = (t.value ?? "").trim();
          if (!url) throw new Error("Missing webhook URL");
          await postWebhook(url, {
            kind: "ipf_product",
            productId,
            title: product.title,
            status: product.status,
            pdfSha256: pdf.sha256,
            // Include PDF inline only if explicitly enabled (size/cost control).
            pdfBase64: (process.env.WEBHOOK_INCLUDE_PDF_BASE64 ?? "false") === "true" ? pdf.bytes.toString("base64") : undefined,
            contentMarkdown: redactPii(markdown),
            contentJson: product.content_json ?? {},
          });
        } else if (t.kind === "teams_webhook") {
          const url = (t.value ?? "").trim();
          if (!url) throw new Error("Missing Teams webhook URL");
          await sendTeamsWebhook(url, { title: product.title, text: redactPii(markdown).slice(0, 3500) });
        } else {
          throw new Error(`Unsupported distribution target kind: ${t.kind}`);
        }

        await updateDistributionRecord(db, tenantId, distributionId, "sent", null);
        await db`
          INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
          VALUES (
            ${randomUUID()},
            ${tenantId},
            ${"product.distribution.sent"},
            ${actor},
            ${"product"},
            ${productId},
            ${db.json({ distributionId, kind: t.kind, target: t.value, pdfSha256: pdf.sha256 })}
          )
        `;
      } catch (err) {
        anyFailed = true;
        const message = String((err as any)?.message ?? err);
        await updateDistributionRecord(db, tenantId, distributionId, "failed", message);
        await db`
          INSERT INTO audit_log (id, tenant_id, action, actor_user_id, target_type, target_id, metadata)
          VALUES (
            ${randomUUID()},
            ${tenantId},
            ${"product.distribution.failed"},
            ${actor},
            ${"product"},
            ${productId},
            ${db.json({ distributionId, kind: t.kind, target: t.value, error: message })}
          )
        `;
      }
    }

    if (!anyFailed) {
      await db`
        UPDATE products
        SET status = ${"distributed"}, distributed_at = NOW(), updated_at = NOW()
        WHERE tenant_id = ${tenantId} AND id = ${productId} AND status = ${"approved"}
      `;
    }

    await db`
      UPDATE run_logs
      SET status = ${anyFailed ? "partial_failed" : "succeeded"},
          output = ${db.json({ productId, pdfSha256: pdf.sha256, targets: targets.map((t) => ({ kind: t.kind, value: t.value })) })}
      WHERE id = ${runId}
    `;
  } catch (err) {
    const message = String((err as any)?.message ?? err);
    await db`
      UPDATE run_logs
      SET status = ${"failed"},
          error = ${message}
      WHERE id = ${runId}
    `;
    throw err;
  }
}


